o	2月24:  
	Write a simple TCP database server (a server that can be queried (询问)about the content（内容） of the sqlite database db1). The provided database has no records, and you will have to populate yourself with data in order to test your code. All the communication will be in plain清楚 text, such that you can test it using the sock tool. 
	The port on which the database server listens is received as parameter参数 from the command命令 line (when starting the server) as follows: server -d <database_file> -p <port>. For example:
________________________________________
$g++ myserver.cpp -l sqlite3 -o myserver
$myserver -d deliberation.db -p 2454. 
________________________________________

This command will start your server, asking it to server on the port 2454, and to serve requests for the database found in the file "deliberation.db". If you are not familiar with ways of parsing standard command lines, read the manual手动 page for using "getopt" in C or scripts: 
________________________________________
$man 3 getopt
$man getopt
________________________________________
There are also java libraries gnu.GetOpt, or my simpler implementation of GetOpt.
//By Marius Calin Silaghi, FIT
//June, 15 2004
// Package implementing standard UNIX "getopt" for JAVA
// To be inherited by main application classes

package mcs.utils;

public class GetOpt{
    public static String optarg=null;
    public static int optind=0, opterr=1;
    public static char optopt;
    public static final char END=(char)-1;
    static int inoptind=0;
//     public static void main(String[]args){
// 	char c;
// 	while((c=getopt(args, "fc:d"))!=END){
// 	    switch(c){
// 	    case 'f': System.out.println("f"); break;
// 	    case 'c': System.out.println("c "+optarg); break;
// 	    case 'd': System.out.println("d"); break;
// 	    case END: System.out.println("-1"); break;
// 	    case '?': System.out.println("?:"+optopt); return;
// 	    default:
// 		 System.out.println("Error: "+c);
// 		 return;
// 	    }
// 	}
// 	if(optind<args.length)
// 	    System.out.println("OPTS:"+args[optind]);
//     }
    public static char getopt(String argv[],
			      String optstring){
	return getopt(argv,optstring.toCharArray());
    }
    public static char getopt(String argv[],
			      char[] optstring){
	int ind=0, i=0, o=0, k=0;
	if((optind<argv.length)&&(inoptind>=argv[optind].length())){
	    inoptind = 0;
	    optind++;
	} 
	if(optind>=argv.length){
	    return END;
	}
	for(k=optind; k<argv.length; k++, inoptind=0) {
	    ind=k+1;
	    optopt=argv[k].charAt(inoptind);
	    if(inoptind==0){
		if((optopt == '-') &&
		   (argv[k].length()==2)&&
		   (argv[k].charAt(1) == '-')){
		    optind = k+1;
		    return END;
		}
		if((optopt != '-')||(argv[k].length()==1)){
		    for(i=k+1; i<argv.length; i++)
			if((argv[i].charAt(0)=='-')&&((argv[i].length()>2)||
			   ((argv[i].length()==2)&&(argv[i].charAt(1) != '-')))){
			    String tmp=argv[i];
			    argv[i] = argv[k];
			    argv[k] = tmp;
			    ind=i+1;
			    break;
			}else
			    if((argv[i].length()==2)&&(argv[i].charAt(0) == '-')
			       &&(argv[i].charAt(1) == '-')){
				String tmp=argv[i];
				argv[i] = argv[k];
				argv[k] = tmp;
				optind=k+1;
				return END;		
			    }
		    if(i==argv.length){//end of options
			optind = k;
			return (char)-1;
		    }
		}
		inoptind++;
		optopt=argv[k].charAt(inoptind);
	    }
	    for(o=0; o<optstring.length; o++){
		if(optstring[o]==optopt){
		    if((o<optstring.length-1)&&(optstring[o+1]==':')){
			if(ind>=argv.length) return ':';
			String tmp=argv[ind];
			argv[ind] = argv[k+1];
			argv[k+1] = tmp;
			optind = k+2;
			inoptind=-1;
			optarg=argv[k+1];
		    }
		    inoptind++;
		    return optopt;
		}
	    }
	    if(o==optstring.length) return '?';
	}
	return END;
    }
}

	The data exchanged 交换by the client and server will pack messages with ASN.1 (the transmitted传送 messages themselves will not be BER, but the text representation表现 of the data, as given on slide 33 in the set of slides on ASN1): 
	the client (user via sock/telnet tool) requests the data. The request is an ASN1 SEQUENCE composed of: 
	a GeneralizedTime UTC formated date of the last snapshot
	a SEQUENCE OF the requested table names from the database. 
Example of client request: 

________________________________________
$sock localhost:2454
{last_snapshot 20001231235959.999Z, tables { peers, organizations}} 

^D
________________________________________

this requests the server running on the local host at port 2454 to dump the "peers" and "organizations" tables, if they were changed since the year 2000, ...
	The server will have to return a database snapshot (as a text with the following text format形式):
	each database table row into an ASN1 SEQUENCE structure, where each field is encoded as an OCTET STRING if present and NULL if absent. 
	each table is packed into an ASN1 SEQUENCE of four elements: 
	an UTF8String specifying the table name,
	a SEQUENCE OF row structures,
	a SEQUENCE OF field names in the proper order, 
	a SEQUENCE OF sqlite field types (PrintableString).
	the database is an ASN1 SEQUENCE of 
	a SEQUENCE OF table structures, 
	a database name in UTF8String, 
	a snapshot date in GeneralizedTime UTC format. 
	Possible steps is implementation执行: 
	Implement the parsing of the command line (with getopt). 
	Implement the listening to the network port and the iterative server. 
	Implement the parsing of the request from the client. 
	Implement the loading of the database and the execution实行 of the SQL command needed  for this request by the client. 
	Pack the result from the client into the corresponding text message that conforms to the ASN1 description. 
	Send the result to the client. 
	Test repeatedly the server using the sock tool (you may have to add data into the database).
	submit the needed ASN1 definitions in a separate file called: database.asn.
	see sqlite documentation and sample programs (last section) at: sqlite.org/quickstart.
	for sqlite support of various programming languages see: SqliteWrappers . 
	Submit: 
	the c/java code, 
	the database.asn file, 
	the database that you used for testing, 
	a document describing the client queries that you used for testing, as well as 
	the architecture of your system. 
•	
o	3月 19: 
	Write a client that can connect to the database server written in milestone 2 and saves all the data in his copy of the database (synchronizing it). 
	For now assume that the client zapps her database and just stores the new data as received. The client downloads all the tables in the remote server (he has a local database with identical tables/structures).
	The client is started with the command: 
	client -d local_database.db -h host_server -p port_server
	Modify the database server to: 
	concurently serve up to 10 clients 
	using up to 10 working threads (one per client)
	making sure to synchronize the access to the database of the server
	encode communication using DER encoded messages according to the provided database.asn definition file (type SyncReques for client, type Database for server).
	500 words documentation. Only .txt (notepad) files are accepted 
	Send instruction of how to compile the code (including a Makefile or a script that performs the compilation) and tests examples 
	Sqlite examples: 
________________________________________
To retrieve the list of available tables you can use one of the queries:
.tables
select tbl_name from sqlite_master; 
To retrieve the whole content of a table mytable use the query: 
select * from mytable;
________________________________________
Use the following ASN.1 definitions file: database.asn
o	4月 6: 
	Write a program combining the two previous milestones such that it can participate in a peer-2-peer system: 
	The program should have: 
	a database server thread which: 
	launches new threads for each client. 
	limits the number of connected remote clients to 10. 
	only serves the tables "peers" and "peers_addresses" 
	for table "peers" the server does not pack and send the "peer_ID" field (e.g., with "SELECT global_peer_ID, name, broadcastable, last_sync_date FROM peers WHERE broadcastable != 0 AND date > $last_snapshot_date") 
	for table "peers_addresses" the server does not pack the field "address_ID" at all, and replaces the "peer_ID" field with the corresponding "peers.global_peer_ID" field (e.g., by "SELECT address, type, global_peer_ID FROM peers JOIN peers_addresses ON peers.peer_ID=peers_addresses.peer_ID WHERE broadcastable != 0 AND peers_addresses.date > $last_snapshot_date"). The "address_ID" at the destination is simply set by auto-incrementation when doing "INSERT INTO peers_addresses (address, type, peer_ID) VALUES ("163.118.73.58:2050", "Socket", 1)".
	a user thread: 
	receives SQL queries from the keyboard and executed them on the database
	a client thread: 
	connects in a cycle to each address in the column "address" of each row of the table "peers_addresses", which have the format: "machine.domain:port", "machine.domain:port". For each connection it should abandon the attempt after 2 seconds if the server does not yet accept the connection.
	Does not delete its database but should update its local copy by adding only new entries (i.e, entries with a new "global_peer_ID"). 
	May specify in its request a snapshot date based on the column "peers.last_sync_date". An empty value (NULL or "") for the snapshot date in the client's SyncRequest message is interpreted as if the whole database (peers & peers_addresses tables) is requested.
	queries each peer for updates to their tables: "peers" and "peers_addresses", but saves only rows containing new "global_peer_ID" entries (the new entries in the 2 tables need to keep their "peer_ID" fields consistent).
	The threads should synchronize for access to the shared database. 
	The messages should conform to datanase.asn, such that your program can communicate with the ones of your colleagues. 
	Submit: (a) the source code, (b) instructions for compiling it, (c) a 500 words documentation describing the way it works 
	Grading: 20% coding, 20% user thread, 40% P2P running,  20% documentation&instructions 
	Command to launch the program:
	myP2P -d database.db -p port
o	4月24: 
	Modify the program at the previous milestone, to provide a directory service. One of the problems with the program in milestone 4 is that a given user which has his same program running on his laptop/phone may connect sometimes time from a different IP, sometimes with a different port. Connection attempts to that user's program (peer) will fail. Two solutions have to be implemented in this last milestone. 
	A directory service (registry): 
	each program maintains a list of directory servers, and the last directory of each peer is added as an address with type "DIR" in the peers_addresses table (it is added in the directory table, and the obtained directoryID is added in the peers_address as field "address": see new table "directory" in deliberation.db, which stores all the directory server addresses seen so far by this program). A "DIR" entry in peers_addresses contains in its "address" field the ID of an entry in the "directory" table. 
	each directory server maintains an sqlite database (use the file directory.db) with a list of connections (domain:port) for each registered global_peer_ID. 
	when a peer cannot be contacted at the old address, clients will query the associated directory server for addresses using format DirectoryRequest in the deliberation.asn. The servers return a DirectoryAnswer. 
	when starting, a client will connect to a current directory server and announce its current address using a DirectoryAnnouncement (certificate and signature fields are not used at this milestone). The directory server updates the address in its database. The servers answers with a DirectoryAnnouncementAnswer. 
	The registry starts with: registry -p port -d directory.db
	New address announcements: 
	Each time a client successfully connects to a server, in the SyncRequest it optionally includes the current domain/IP and port of its associated server, a "broadcastable" desire, and an optional directory domain and port (see new database.asn). 
	For this purpose, the program accepts a start-up option "-p port -d database.db -u -b -r domain:port -D -g my_global_ID" (-u will make it include the new address in the SyncRequest OPTIONAL field, -b stands for broadcastable address, and -r passes the desired directory service address. If -D is given, the client will announce itself to the current directory service, -g tells the peer its own "global_ID"). Sample programs for finding a new address are available here (C, Java).
	Grading: doc, slides of the 5 minutes talk, makefile, directory service, coding (since these programs will be used further in the Fall Cryptology class, each file header should contain the GPL license: /*License: GNU General Public License version 2*/).